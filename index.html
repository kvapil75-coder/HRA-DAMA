<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <title>üëë D√°ma üëë</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* ===== Z√ÅKLADN√ç VZHLED STR√ÅNKY ===== */
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #145214, #001a00 60%);
      color: #fff;
      text-align: center;
      padding: 20px;
      margin: 0;
    }

    #game {
      max-width: 980px;
      margin: 0 auto;
      background: linear-gradient(145deg, #24262b, #17181c);
      padding: 20px;
      border-radius: 18px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.7);
      position: relative;
      border: 1px solid rgba(255,255,255,0.06);
    }

    h2 {
      margin: 0;
      font-size: 2.6rem;
      letter-spacing: 0.12em;
      text-shadow: 0 0 12px rgba(255,215,0,0.7);
    }

    /* ===== INFO TEXT NAD HRAC√ç PLOCHOU ===== */
    #info {
      margin-top: 6px;
      margin-bottom: 10px;
      font-weight: 600;
      text-align: center;
      min-height: 1.5em;
      font-size: 1.1rem;
      color: #e3fbe3;
    }

    /* ===== HORN√ç PANEL S M√ìDY ===== */
    #topBar {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      margin-top: 4px;
    }

    #modeButtons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 4px;
    }

    .modeBtn {
      padding: 6px 16px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      cursor: pointer;
      background: rgba(255,255,255,0.06);
      color: #fff;
      font-weight: 600;
      font-size: 0.95rem;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.2s, transform 0.1s, box-shadow 0.2s, border-color 0.2s;
    }

    .modeBtn:hover {
      background: rgba(117, 180, 117, 0.3);
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0,0,0,0.4);
      border-color: rgba(176, 255, 176, 0.7);
    }

    .modeBtn.active {
      background: #35a34a;
      box-shadow: 0 8px 16px rgba(0,0,0,0.5);
      border-color: #9bf3ab;
    }

    #score {
      margin-top: 8px;
      font-weight: 600;
      font-size: 0.95rem;
      color: #e0ffe0;
    }

    /* ===== HRAC√ç PLOCHA + VY≈òAZEN√â KAMENY ===== */
    #playArea {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 16px;
      margin-top: 14px;
    }

    #board {
      width: 440px;
      max-width: 60vw;
      aspect-ratio: 1 / 1;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      border: 6px solid #ff0000;
      box-shadow: 0 0 18px rgba(255,0,0,0.7);
      border-radius: 10px;
      overflow: hidden;
      background: #000;
    }

    .capturedColumn {
      width: 120px;
      min-height: 120px;
      padding: 10px;
      background: #b58863;
      border-radius: 12px;
      border: 2px solid #8a6245;
      box-sizing: border-box;
      box-shadow: inset 0 3px 10px rgba(0,0,0,0.4);
    }

    .capturedColumn > div:first-child {
      font-size: 0.9rem;
      margin-bottom: 6px;
      font-weight: 700;
      text-transform: uppercase;
      color: #2c1c10;
    }

    #capturedListWhite,
    #capturedListBlack {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .captured-piece {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      position: relative;
      box-sizing: border-box;
      overflow: hidden;
    }

    .captured-piece.white {
      background: radial-gradient(circle at 30% 30%, #ffffff, #d5d5d5);
      border: 2px solid #c2c2c2;
    }

    .captured-piece.black {
      background: radial-gradient(circle at 30% 30%, #444, #050505);
      border: 2px solid #2a2a2a;
    }

    /* ===== POLE A FIGURKY ===== */
    .square {
      position: relative;
      box-sizing: border-box;
      width: 100%;
      aspect-ratio: 1 / 1;   /* pevn√Ω ƒçtverec */
      overflow: hidden;
    }

    .light {
      background: #f0d9b5;
    }

    .dark {
      background: #b58863;
      box-shadow: inset 0 0 6px rgba(0,0,0,0.35);
    }

    .square.selected {
      outline: 3px solid #ffeb3b;
      outline-offset: -3px;
      box-shadow: inset 0 0 10px rgba(255,235,59,0.9);
    }

    .piece {
      position: absolute;      /* pevn√© um√≠stƒõn√≠ do st≈ôedu */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 70%;
      height: 70%;
      border-radius: 50%;
      box-sizing: border-box;
      cursor: pointer;
      display: block;
      overflow: hidden;
      transition: transform 0.1s, box-shadow 0.1s;
    }

    .piece.white {
      background: radial-gradient(circle at 30% 30%, #ffffff, #dcdcdc);
      border: 2px solid #cfcfcf;
      box-shadow: 0 3px 8px rgba(0,0,0,0.5);
    }

    .piece.black {
      background: radial-gradient(circle at 30% 30%, #555, #050505);
      border: 2px solid #2c2c2c;
      box-shadow: 0 3px 8px rgba(0,0,0,0.5);
    }

    .piece:hover {
      transform: translate(-50%, -52%); /* lehk√© nadzvednut√≠, ale z≈Øst√°v√° vyst≈ôedƒõn√° */
      box-shadow: 0 6px 16px rgba(0,0,0,0.6);
    }

    .piece.king {
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.9), 0 4px 12px rgba(0,0,0,0.7);
      border-color: #fadc5c;
    }

    .crown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 16px;
      pointer-events: none;
      text-shadow: 0 0 6px rgba(0,0,0,0.9);
    }

    /* ===== ANIMACE LET√çC√çHO SEBRAN√âHO KAMENE ===== */
    .capture-fly {
      position: fixed;
      pointer-events: none;
      z-index: 999;
      transition: transform 0.6s ease, opacity 0.6s ease;
    }

    /* ===== BLINK NUTN√âHO KAMENE (3√ó) ===== */
    @keyframes blink-red-3x {
      0%, 100% { box-shadow: 0 0 6px rgba(255, 0, 0, 0.9); }
      50% { box-shadow: 0 0 20px rgba(255, 0, 0, 1); }
    }
    .forced-flash {
      animation: blink-red-3x 0.5s 3;
    }

    /* ===== OVERLAY PO V√ùH≈òE ===== */
    #overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    #overlay.hidden {
      display: none;
    }

    #overlayContent {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    #overlayText {
      font-size: 2.5rem;
      font-weight: 700;
      color: #fff;
    }

    #overlayNewGameBtn {
      padding: 8px 20px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: #4caf50;
      color: #fff;
      font-size: 1rem;
      font-weight: 700;
      box-shadow: 0 6px 14px rgba(0,0,0,0.6);
      border: 1px solid #bdfcc5;
    }

    #overlayNewGameBtn:hover {
      background: #43a047;
    }
  </style>
</head>

<body>
  <div id="game">

    <h2>üëë D√ÅMA üëë</h2>

    <!-- INFO naho≈ôe -->
    <div id="info"></div>

    <div id="topBar">
      <div id="modeButtons">
        <button id="mode1Btn" class="modeBtn">1 HR√Åƒå</button>
        <button id="mode2Btn" class="modeBtn">2 HR√ÅƒåI</button>
      </div>
    </div>

    <div id="score">
      <span id="scoreWhite">B√≠l√Ω ‚ö™: 0</span> |
      <span id="scoreBlack">ƒåern√Ω ‚ö´: 0</span>
    </div>

    <div id="playArea">
      <div class="capturedColumn" id="capturedWhiteColumn">
        <div>Vy≈ôazen√© b√≠l√©</div>
        <div id="capturedListWhite"></div>
      </div>

      <div id="board"></div>

      <div class="capturedColumn" id="capturedBlackColumn">
        <div>Vy≈ôazen√© ƒçern√©</div>
        <div id="capturedListBlack"></div>
      </div>
    </div>

    <div id="overlay" class="hidden">
      <div id="overlayContent">
        <div id="overlayText"></div>
        <button id="overlayNewGameBtn">Nov√° hra</button>
      </div>
    </div>

  </div>

  <script>
    const boardEl = document.getElementById("board");
    const infoEl = document.getElementById("info");
    const scoreWhiteEl = document.getElementById("scoreWhite");
    const scoreBlackEl = document.getElementById("scoreBlack");
    const overlayEl = document.getElementById("overlay");
    const overlayTextEl = document.getElementById("overlayText");
    const overlayNewGameBtn = document.getElementById("overlayNewGameBtn");

    const capturedListWhiteEl = document.getElementById("capturedListWhite");
    const capturedListBlackEl = document.getElementById("capturedListBlack");

    const mode1Btn = document.getElementById("mode1Btn");
    const mode2Btn = document.getElementById("mode2Btn");

    const SIZE = 8;
    let board = [];
    const WHITE = "w";
    const BLACK = "b";

    let currentPlayer = WHITE;
    let selected = null;
    let gameOver = false;

    let scoreWhite = 0;
    let scoreBlack = 0;

    let gameMode = "vsAI";

    let capturedWhitePieces = [];
    let capturedBlackPieces = [];

    /* ===== ZVUKY ===== */
    let audioCtx = null;
    function getAudioCtx() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioCtx;
    }

    function playBeep(freq, durationMs, volume = 0.1) {
      try {
        const ctx = getAudioCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.value = freq;
        gain.gain.value = volume;
        osc.start();
        osc.stop(ctx.currentTime + durationMs / 1000);
      } catch (e) {}
    }

    function playMoveSound() {
      playBeep(600, 80, 0.08);
    }

    function playCaptureSound() {
      playBeep(320, 150, 0.12);
      setTimeout(() => playBeep(500, 120, 0.1), 120);
    }

    function playWinSound() {
      playBeep(700, 180, 0.12);
      setTimeout(() => playBeep(900, 180, 0.12), 180);
      setTimeout(() => playBeep(1100, 220, 0.12), 360);
    }

    mode1Btn.onclick = () => setMode("vsAI");
    mode2Btn.onclick = () => setMode("twoPlayers");
    overlayNewGameBtn.onclick = () => initBoard();

    function setMode(mode) {
      gameMode = mode;
      mode1Btn.classList.toggle("active", mode === "vsAI");
      mode2Btn.classList.toggle("active", mode === "twoPlayers");
      initBoard();
    }

    function createPiece(player, king = false) {
      return { player, king };
    }

    function initBoard() {
      board = Array.from({ length: SIZE }, () =>
        Array.from({ length: SIZE }, () => null)
      );

      for (let r = 0; r < 3; r++)
        for (let c = 0; c < SIZE; c++)
          if ((r + c) % 2 === 1) board[r][c] = createPiece(BLACK);

      for (let r = 5; r < 8; r++)
        for (let c = 0; c < SIZE; c++)
          if ((r + c) % 2 === 1) board[r][c] = createPiece(WHITE);

      currentPlayer = WHITE;
      selected = null;
      scoreWhite = 0;
      scoreBlack = 0;
      gameOver = false;

      capturedWhitePieces = [];
      capturedBlackPieces = [];
      updateCapturedDisplays();

      overlayEl.classList.add("hidden");
      updateScore();
      render();
      updateInfo();
    }

    function updateInfo(msg) {
      if (msg) {
        infoEl.textContent = msg;
        return;
      }
      if (gameOver) {
        infoEl.textContent = "";
        return;
      }
      infoEl.textContent =
        currentPlayer === WHITE
          ? gameMode === "vsAI"
            ? "Na tahu: B√çL√ù (ty)"
            : "Na tahu: B√çL√ù"
          : gameMode === "vsAI"
          ? "Na tahu: ƒåERN√ù (automat)"
          : "Na tahu: ƒåERN√ù";
    }

    function updateScore() {
      scoreWhiteEl.textContent = `B√≠l√Ω ‚ö™: ${scoreWhite}`;
      scoreBlackEl.textContent = `ƒåern√Ω ‚ö´: ${scoreBlack}`;
    }

    function updateCapturedDisplays() {
      capturedListWhiteEl.innerHTML = "";
      capturedWhitePieces.forEach(p => {
        const div = document.createElement("div");
        div.className = "captured-piece white";
        if (p.king) {
          const crown = document.createElement("div");
          crown.className = "crown";
          crown.textContent = "üëë";
          div.appendChild(crown);
        }
        capturedListWhiteEl.appendChild(div);
      });

      capturedListBlackEl.innerHTML = "";
      capturedBlackPieces.forEach(p => {
        const div = document.createElement("div");
        div.className = "captured-piece black";
        if (p.king) {
          const crown = document.createElement("div");
          crown.className = "crown";
          crown.textContent = "üëë";
          div.appendChild(crown);
        }
        capturedListBlackEl.appendChild(div);
      });
    }

    function render() {
      boardEl.innerHTML = "";
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          const square = document.createElement("div");
          square.classList.add("square", (r + c) % 2 === 0 ? "light" : "dark");
          square.dataset.row = r;
          square.dataset.col = c;

          if (selected && selected.row === r && selected.col === c)
            square.classList.add("selected");

          const cell = board[r][c];
          if (cell) {
            const pieceEl = document.createElement("div");
            pieceEl.classList.add("piece", cell.player === WHITE ? "white" : "black");

            if (cell.king) {
              pieceEl.classList.add("king");
              const crown = document.createElement("div");
              crown.className = "crown";
              crown.textContent = "üëë";
              pieceEl.appendChild(crown);
            }

            square.appendChild(pieceEl);
          }

          square.onclick = () => handleClick(r, c);
          boardEl.appendChild(square);
        }
      }
    }

    function handleClick(r, c) {
      if (gameOver) return;
      if (gameMode === "vsAI" && currentPlayer !== WHITE) return;

      const cell = board[r][c];

      if (selected && (selected.row !== r || selected.col !== c)) {
        attemptMove(currentPlayer, selected.row, selected.col, r, c);
        return;
      }

      if (cell && cell.player === currentPlayer) {
        selected = { row: r, col: c };
        render();
      }
    }

    function isOnBoard(r, c) {
      return r >= 0 && r < SIZE && c >= 0 && c < SIZE;
    }

    function getAllMovesFor(player) {
      const moves = [];
      for (let r1 = 0; r1 < SIZE; r1++) {
        for (let c1 = 0; c1 < SIZE; c1++) {
          const piece = board[r1][c1];
          if (!piece || piece.player !== player) continue;

          for (let r2 = 0; r2 < SIZE; r2++) {
            for (let c2 = 0; c2 < SIZE; c2++) {
              const result = validateMove(player, r1, c1, r2, c2);
              if (result.valid) {
                moves.push({
                  from: { r: r1, c: c1 },
                  to: { r: r2, c: c2 },
                  capture: result.capture,
                  captured: result.captured || [],
                });
              }
            }
          }
        }
      }
      return moves;
    }

    function computeForcedCaptures(player) {
      const moves = getAllMovesFor(player);
      const captureMoves = moves.filter(m => m.capture);
      const positions = captureMoves
        .map(m => m.from)
        .filter((v, i, a) => a.findIndex(t => t.r === v.r && t.c === v.c) === i);
      return { captureMoves, positions };
    }

    function flashForcedPieces(positions) {
      render();
      const squares = boardEl.children;
      for (let sq of squares) {
        const r = +sq.dataset.row;
        const c = +sq.dataset.col;
        if (positions.some(p => p.r === r && p.c === c)) {
          if (sq.firstChild) sq.firstChild.classList.add("forced-flash");
        }
      }
      setTimeout(() => {
        document.querySelectorAll(".forced-flash").forEach(el =>
          el.classList.remove("forced-flash")
        );
      }, 2000);
    }

    function showWinner(player) {
      gameOver = true;
      overlayTextEl.textContent =
        player === WHITE ? "B√≠l√Ω vyhr√°l!" : "ƒåern√Ω vyhr√°l!";
      overlayEl.classList.remove("hidden");
      playWinSound();
      updateInfo();
    }

    function checkWinner() {
      const whiteMoves = getAllMovesFor(WHITE);
      const blackMoves = getAllMovesFor(BLACK);
      const whitePieces = board.flat().filter(p => p && p.player === WHITE).length;
      const blackPieces = board.flat().filter(p => p && p.player === BLACK).length;

      if (whitePieces === 0 || whiteMoves.length === 0) return BLACK;
      if (blackPieces === 0 || blackMoves.length === 0) return WHITE;
      return null;
    }

    function validateMove(player, r1, c1, r2, c2) {
      if (!isOnBoard(r1, c1) || !isOnBoard(r2, c2)) return { valid: false };
      const piece = board[r1][c1];
      if (!piece || piece.player !== player) return { valid: false };
      if (board[r2][c2] !== null) return { valid: false };

      const dr = r2 - r1;
      const dc = c2 - c1;
      if (Math.abs(dr) !== Math.abs(dc)) return { valid: false };

      const dirR = dr > 0 ? 1 : -1;
      const dirC = dc > 0 ? 1 : -1;
      const dist = Math.abs(dr);

      if (piece.king) {
        const captured = [];
        let r = r1 + dirR;
        let c = c1 + dirC;
        while (!(r === r2 && c === c2)) {
          const cell = board[r][c];
          if (cell) {
            if (cell.player === player) return { valid: false };
            captured.push({ r, c });
          }
          r += dirR;
          c += dirC;
        }
        return { valid: true, capture: captured.length > 0, captured };
      }

      const forward = player === WHITE ? -1 : 1;
      if (dirR !== forward) return { valid: false };

      if (dist === 1) return { valid: true, capture: false, captured: [] };

      if (dist === 2) {
        const midR = r1 + dirR;
        const midC = c1 + dirC;
        const midPiece = board[midR][midC];
        if (midPiece && midPiece.player !== player) {
          return {
            valid: true,
            capture: true,
            captured: [{ r: midR, c: midC }]
          };
        }
      }

      return { valid: false };
    }

    function promoteIfNeeded(player, r, piece) {
      if (!piece.king) {
        if (player === WHITE && r === 0) piece.king = true;
        if (player === BLACK && r === SIZE - 1) piece.king = true;
      }
    }

    function animateCapturedPiece(pos, player, isKing) {
      const squares = boardEl.children;
      let sourceSquare = null;
      for (let sq of squares) {
        if (+sq.dataset.row === pos.r && +sq.dataset.col === pos.c) {
          sourceSquare = sq;
          break;
        }
      }
      if (!sourceSquare) return;
      const pieceEl = sourceSquare.querySelector(".piece");
      if (!pieceEl) return;

      const fromRect = pieceEl.getBoundingClientRect();
      const targetList = player === WHITE ? capturedListWhiteEl : capturedListBlackEl;
      const toRect = targetList.getBoundingClientRect();

      const fly = pieceEl.cloneNode(true);
      fly.classList.add("capture-fly");
      document.body.appendChild(fly);

      fly.style.left = fromRect.left + "px";
      fly.style.top = fromRect.top + "px";
      fly.style.width = fromRect.width + "px";
      fly.style.height = fromRect.height + "px";
      fly.style.opacity = "1";

      const dx = (toRect.left + toRect.width / 2) - (fromRect.left + fromRect.width / 2);
      const dy = (toRect.top + toRect.height / 2) - (fromRect.top + fromRect.height / 2);

      requestAnimationFrame(() => {
        fly.style.transform = `translate(${dx}px, ${dy}px) scale(0.4)`;
        fly.style.opacity = "0.1";
      });

      fly.addEventListener("transitionend", () => {
        fly.remove();
      });
    }

    function performMove(player, r1, c1, r2, c2, data) {
      const piece = board[r1][c1];

      if (data.capture && data.captured) {
        data.captured.forEach(pos => {
          const capturedPiece = board[pos.r][pos.c];
          if (capturedPiece) {
            animateCapturedPiece(pos, capturedPiece.player, capturedPiece.king);
          }
        });
      }

      board[r1][c1] = null;
      board[r2][c2] = piece;

      if (data.capture) {
        data.captured.forEach(pos => {
          const captured = board[pos.r][pos.c];
          if (captured) {
            if (captured.player === BLACK) scoreWhite++;
            else scoreBlack++;
            if (captured.player === WHITE) capturedWhitePieces.push(captured);
            else capturedBlackPieces.push(captured);
          }
          board[pos.r][pos.c] = null;
        });
        updateCapturedDisplays();
      }

      promoteIfNeeded(player, r2, piece);

      if (data.capture) playCaptureSound();
      else playMoveSound();
    }

    function attemptMove(player, r1, c1, r2, c2) {
      if (gameOver) return;

      const { captureMoves, positions } = computeForcedCaptures(player);
      const forced = captureMoves.length > 0;

      const res = validateMove(player, r1, c1, r2, c2);

      if (!res.valid || (forced && !res.capture)) {
        if (forced) {
          updateInfo("Mus√≠≈° br√°t kamenem, kter√Ω m≈Ø≈æe sebrat soupe≈ôe!");
          flashForcedPieces(positions);
        } else {
          updateInfo();
        }
        selected = null;
        return;
      }

      performMove(player, r1, c1, r2, c2, res);

      const winner = checkWinner();
      if (winner) {
        render();
        showWinner(winner);
        return;
      }

      selected = null;
      currentPlayer = player === WHITE ? BLACK : WHITE;
      render();
      updateInfo();

      if (gameMode === "vsAI" && currentPlayer === BLACK) {
        setTimeout(makeAIMove, 500);
      }
    }

    function makeAIMove() {
      if (gameOver) return;

      const moves = getAllMovesFor(BLACK);
      const captures = moves.filter(m => m.capture);
      const pool = captures.length ? captures : moves;
      if (pool.length === 0) {
        showWinner(WHITE);
        return;
      }

      const move = pool[Math.floor(Math.random() * pool.length)];
      performMove(BLACK, move.from.r, move.from.c, move.to.r, move.to.c, move);

      const winner = checkWinner();
      if (winner) {
        render();
        showWinner(winner);
        return;
      }

      currentPlayer = WHITE;
      render();
      updateInfo();
    }

    setMode("vsAI");
  </script>

</body>
</html>
